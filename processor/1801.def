// ******************************************************************************************
// ******************************************************************************************
//
//										Cosmac Coinop Core
//
// ******************************************************************************************
// ******************************************************************************************
//
//		All references are to the Cosmac Users manual (1975 version)
//
//	@F 	Eflag number (lower 2 bits+1)
//	@H	lower 4 bits in hexadecimal
//	@P 	lower 3 bits in decimal
//	@R 	lower 4 bits in decimal.
//
// ******************************************************************************************
//								Register operations (page 15)
// ******************************************************************************************

10-1F	"INC R@H"			R[@R]++											// Increment register
20-2F 	"DEC R@H"			R[@R]--											// Decrement register

80-8F	"GLO R@H"			D = R[@R]										// Get low byte
90-9F	"GHI R@H"			D = R[@R] >> 8 									// Get high byte
A0-AF 	"PLO R@H"			R[@R] = (R[@R] & 0xFF00) | D 					// Put low byte
B0-BF 	"PHI R@H"			R[@R] = (R[@R] & 0x00FF) | (((WORD16)D) << 8)	// Put high byte

// ******************************************************************************************
//									Memory Reference (page 17)
// ******************************************************************************************

40-4F 	"LDA R@H"			D = READ(R[@R]);R[@R]++							// Load via R & increment
50-5F 	"STR R@H"			WRITE(R[@R],D)									// Save via R

// ******************************************************************************************
//							ALU Operations using M(R(X)) (page 18)
// ******************************************************************************************

F0 		"LDX"				D = READ(R[X])									// Load by X
F1 		"OR"				D |= READ(R[X])									// Or memory
F2 		"AND"				D &= READ(R[X])									// And memory
F3 		"XOR"				D ^= READ(R[X])									// Xor memory
F4 		"ADD"				ADD(READ(R[X]))									// Add memory
F5 		"SD"				SUB(READ(R[X]),D)								// Subtract D
F7 		"SM"				SUB(D,READ(R[X]))								// Subtract memory

:#define ADD(v) 	{ temp16 = D + (v);D = temp16;DF = temp16 >> 8; }		// Add/Sub macros
:#define SUB(a,b)	{ temp16 = (a) + ((b)^0xFF) + 1;D = temp16;DF = temp16 >> 8; }

F6 		"SHR"				DF = D & 1;D = (D >> 1) & 0x7F 					// Shift D right into DF

// ******************************************************************************************
//					ALU operations using M(R(P)) (e.g. immediate) (page 22)
// ******************************************************************************************

F8 		"LDI *"				D = FETCH()										// Load immediate
F9 		"ORI *"				D |= FETCH()									// Or immediate
FA 		"ANI *"				D &= FETCH()									// And immediate
FB 		"XRI *"				D ^= FETCH()									// Xor immediate
FC 		"ADI *"				ADD(FETCH())									// Add immediate
FD 		"SDI *"				SUB(FETCH(),D)									// Subtract D immediate
FF 		"SMI *"				SUB(D,FETCH())									// Subtract immediate

// ******************************************************************************************
//							Input/Output Byte Transfer (page 24)
// ******************************************************************************************

60-67	"OUT @P" 			OUTPORT@P(READ(R[X]));R[X]++ 					// Output from memory X
68-6F 	"INP @P"			WRITE(R[X],INPORT@P())							// Input to memory X

// ******************************************************************************************
//										Branching (page 25)
// ******************************************************************************************

30 		"BR *"				FETCHBR();BRANCH();								// Branch unconditionally
32 		"BZ *"				FETCHBR();if (D == 0) BRANCH();					// Branch if zero
33 		"BDF *"				FETCHBR();if (DF != 0) BRANCH();				// Branch if DF set
34-37 	"B@F *"				FETCHBR();if (EFLAG@F() != 0) BRANCH();			// Branch if EFLAG set
38 		"SKP"				R[P]++											// Skip instruction
3A 		"BNZ *"				FETCHBR();if (D != 0) BRANCH();					// Branch if non zero
3B 		"BNF *"				FETCHBR();if (DF == 0) BRANCH();				// Branch if DF clear
3C-3F 	"BN@F *"			FETCHBR();if (EFLAG@F() == 0) BRANCH();			// Branch if EFLAG clear

:#define FETCHBR()	temp8 = FETCH();										// Fetch branch address
:#define BRANCH() 	{ R[P] = (R[P] & 0xFF00) | temp8; }						// Execute branch

// ******************************************************************************************
//										Control (page 27)
// ******************************************************************************************

00 		"IDL"				R[P]-- 											// Idle, interrupt fixes

D0-DF 	"SEP R@H"			P = @R 											// Set P
E0-EF 	"SEX R@H"			X = @R 											// Set R

// ******************************************************************************************
//									Interrupt Handling (page 28)
// ******************************************************************************************

:static void _1801Interrupt() {
:	if (READ(R[P]) == 0) R[P]++;											// Exit Idle mode.
:	T = (X << 4) | P;														// Save X:P in T
:	P = 1;																	// Set P to 1
:	X = 2;																	// Set X to 2
:	IE = 0;																	// Disable Interrupts	
:}

78 		"SAV"				WRITE(R[X],T)									// Save T register

70 		"RET"				RETURN();IE = 1;								// Return and enable
71 		"DIS"				RETURN();IE = 0;								// Return and disable

:#define RETURN() { temp8 = READ(R[X]);R[X]++;X = temp8 >> 4;P = temp8 & 0x0F; }	

:static void _1801Reset() {
:	P = 0;R[0] = 0;IE = 1;													// See page 35
:	DF &= 1;																// Force to a valid value	
:}
