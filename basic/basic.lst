 AS V1.42 Beta [Bld 114] - source file basic.asm - page 1 - 11/12/2016 12:23:03


       1/       0 :                     	
       2/       0 :                     		cpu		8008new
       3/       0 :                     
       4/       0 :                     ;
       5/       0 :                     ;	Savings : shift to 128 bytes/line or 256 bytes/line
       6/       0 :                     ; 	Drop and and xor ? (consequences for math.)
       7/       0 :                     ;
       8/       0 :                     ;	variables A-Z
       9/       0 :                     ; 	keywords in lower case.
      10/       0 :                     ;
      11/       0 :                     ;
      12/       0 :                     ;	Coding:
      13/       0 :                     ;		Enter program lines (also empty lines)
      14/       0 :                     ;		Auto-enter program [seperate]
      15/       0 :                     ;		new run let goto input print call exit (return) view (list) key (character) out (character)
      16/       0 :                     ;
      17/       0 :                     ;
      18/       0 :                     
      19/       0 : =1000H              VariablePage = 	1000h 											; this page has variables offset from A = 0
      20/       0 : =1100H              InputPage = 	1100h 											; text input goes here.
      21/       0 :                     
      22/       0 : =2000H              ProgramMemory = 2000h 											; 127 program lines go here. 64 bytes each.
      23/       0 :                     																; line 1 at 2040h, 2 at 2080h etc.
      24/       0 :                     		org 	0
      25/       0 :                     
      26/       0 :                     ; ***********************************************************************************************
      27/       0 :                     ; ***********************************************************************************************
      28/       0 :                     ;
      29/       0 :                     ;									Main command loop
      30/       0 :                     ;
      31/       0 :                     ; ***********************************************************************************************
      32/       0 :                     ; ***********************************************************************************************
      33/       0 :                     
      34/       0 :                     NextCommand:
      35/       0 : 0E 5D               		mvi	 	b,']' 											; print a ] prompt
      36/       2 : 15                  		rst 	PrintCharacter 									
      37/       3 : 1D                  		rst 	InputLine 										; get the line.
      38/       4 : 46 CB 00            		call 	CommandExecute 									; execute it
      39/       7 : 05                  		rst 	NextCommand 									; loop back.
      40/       8 :                     
      41/       8 :                     ; ***********************************************************************************************
      42/       8 :                     ; ***********************************************************************************************
      43/       8 :                     ;
      44/       8 :                     ;							Read next non space character from (HL)
      45/       8 :                     ;
      46/       8 :                     ; ***********************************************************************************************
      47/       8 :                     ; ***********************************************************************************************
      48/       8 :                     
      49/       8 :                     		org 	8
      50/       8 :                     GetNextCharacter:
      51/       8 : C7                  		mov 	a,m 											; read character.
      52/       9 : 30                  		inr 	l 												; and advance.
      53/       A : 3C 20               		cpi 	' '												; if space
      54/       C : 68 08 00            		jz 		GetNextCharacter 								; get another one.
      55/       F : 07                  		ret
      56/      10 :                     
      57/      10 :                     ; ***********************************************************************************************
      58/      10 :                     ; ***********************************************************************************************
      59/      10 :                     ;
      60/      10 :                     ;							Print Character in B, returned in A+B
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 2 - 11/12/2016 12:23:03


      61/      10 :                     ;
      62/      10 :                     ; ***********************************************************************************************
      63/      10 :                     ; ***********************************************************************************************
      64/      10 :                     
      65/      10 :                     PrintCharacter:
      66/      10 : 43                  		in 		1 												; check the ready to send flag
      67/      11 : B0                  		ora 	a
      68/      12 : 50 10 00            		jp 		PrintCharacter 									; jump back if not ready
      69/      15 : C1                  		mov 	a,b 											; send B to port 8.
      70/      16 : 51                  		out 	8
      71/      17 : 07                  		ret
      72/      18 :                     
      73/      18 :                     ; ***********************************************************************************************
      74/      18 :                     ; ***********************************************************************************************
      75/      18 :                     ;	
      76/      18 :                     ;								Input a line to InputPage, ASCIIZ.
      77/      18 :                     ;
      78/      18 :                     ;	On exit HL points to line buffer.
      79/      18 :                     ;
      80/      18 :                     ; ***********************************************************************************************
      81/      18 :                     ; ***********************************************************************************************
      82/      18 :                     
      83/      18 :                     InputLine:
      84/      18 : 2E 11               		mvi 	h,InputPage/256 								; HL points to input buffer
      85/      1A :                     __CLStartLine:		
      86/      1A : 36 01               		mvi 	l,1  											; point to start of line+1
      87/      1C :                     __CLPreviousCharacter:		
      88/      1C : 31                  		dcr 	l 												; go back 1
      89/      1D : 70 1A 00            		jm 		__CLStartLine 									; gone too far, restart.
      90/      20 :                     __CLNextCharacterInput:
      91/      20 : 41                  		in 		0 												; read keyboard
      92/      21 : B0                  		ora 	a
      93/      22 : 68 20 00            		jz 		__CLNextCharacterInput
      94/      25 : C8                  		mov 	b,a 											; echo it
      95/      26 : 15                  		rst 	PrintCharacter
      96/      27 : C1                  		mov 	a,b 											; get character back.
      97/      28 : 3C 08               		cpi 	8 												; is it BS
      98/      2A : 68 1C 00            		jz 		__CLPreviousCharacter
      99/      2D : F8                  		mov 	m,a 											; write it out
     100/      2E : 30                  		inr 	l 												; next slot
     101/      2F : 2C 0D               		xri 	13   											; if CR then this will set A = 0
     102/      31 : 48 20 00            		jnz 	__CLNextCharacterInput
     103/      34 : 31                  		dcr 	l 												; replace last character with 00
     104/      35 : F8                  		mov 	m,a 
     105/      36 : F0                  		mov 	l,a 											; point HL to start of line.
     106/      37 : 07                  		ret
     107/      38 :                     
     108/      38 :                     ; ***********************************************************************************************
     109/      38 :                     ; ***********************************************************************************************
     110/      38 :                     ;
     111/      38 :                     ;							Evaluate string at HL. Returns result in B. 
     112/      38 :                     ;
     113/      38 :                     ;	Operators are + - * / and , (xor) . (and). Terms are variables a-zA-Z and integer constants
     114/      38 :                     ;
     115/      38 :                     ;	Not awfully syntax checked :) x/0 returns 0. Technically : and up are all variables.
     116/      38 :                     ;
     117/      38 :                     ;	On exit HL points to found unknown character.
     118/      38 :                     ; 	On exit DE points to the line number if it's a program line (that way round)
     119/      38 :                     ;
     120/      38 :                     ; ***********************************************************************************************
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 3 - 11/12/2016 12:23:03


     121/      38 :                     ; ***********************************************************************************************
     122/      38 :                     
     123/      38 :                     		org 	038h
     124/      38 :                     Evaluate:
     125/      38 : A8                  		xra 	a
     126/      39 : C8                  		mov 	b,a 											; b is current left value
     127/      3A : D8                  		mov 	d,a 											; d is current right value
     128/      3B : 16 01               		mvi 	c,1 											; c is current operator (+ = 1)
     129/      3D :                     AddDigit:
     130/      3D : E0                  		mov 	e,a 											; save new value in E
     131/      3E : C3                  		mov 	a,d 											; multiply D by 10
     132/      3F : 80                  		add 	a
     133/      40 : 80                  		add 	a
     134/      41 : 83                  		add 	d 												; A is now D x 5
     135/      42 : 80                  		add 	a 												; A is now D x 10
     136/      43 : 84                  		add 	e 												; add the new digit.
     137/      44 : D8                  		mov 	d,a 											; put back in D.
     138/      45 :                     NextCharacter:
     139/      45 : 0D                  		rst 	GetNextCharacter 								; get next character.
     140/      46 : 14 3A               		sui 	58 												; 58 - 127 are maybe variables.
     141/      48 : 50 72 00            		jp  	__IsVariable
     142/      4B : 04 0A               		adi 	10 												; 0-9 for digits.
     143/      4D : 50 3D 00            		jp 		AddDigit 										; if that, add to current right and goback.
     144/      50 : 04 06               		adi 	6 												; 0-5 for * + , - . /
     145/      52 : E0                  		mov 	e,a 											; save next operator in E.
     146/      53 : 46 87 00            		call 	SubEvaluator 									; do operation 0-5.
     147/      56 : C8                  		mov 	b,a 											; save the result in B
     148/      57 : 1E 00               		mvi 	d,0  											; clear the right hand side.
     149/      59 : D4                  		mov 	c,e 											; put next operator in C 
     150/      5A : C2                  		mov 	a,c 											; look at that operator
     151/      5B : B0                  		ora 	a 												; if +ve loop back next calculation
     152/      5C : 50 45 00            		jp 		NextCharacter 
     153/      5F : D9                  		mov 	d,b 											; put result in D
     154/      60 :                     ExitEvaluate1:		
     155/      60 : CB                  		mov 	b,d 											; put result in B
     156/      61 : 31                  		dcr  	l 												; gone too far, go back one.
     157/      62 : C1                  		mov 	a,b 											; get result to set up program pointer.
     158/      63 : 34 80               		ori 	080h 											; set bit 7 , which will be bit 5 if shift x 2
     159/      65 : 1A                  		rar 													; also CC for this.
     160/      66 : D8                  		mov 	d,a 											; put shifted right once into D
     161/      67 : 06 00               		mvi 	a,0 											; 
     162/      69 : 1A                  		rar  													; will clear C again.
     163/      6A : E0                  		mov 	e,a  									
     164/      6B : C3                  		mov 	a,d 											; now shift DE right once more.
     165/      6C : 1A                  		rar
     166/      6D : D8                  		mov 	d,a
     167/      6E : C4                  		mov 	a,e
     168/      6F : 1A                  		rar
     169/      70 : E0                  		mov		e,a
     170/      71 :                     
     171/      71 : 07                  		ret
     172/      72 :                     ;
     173/      72 :                     ;		Variable ? A contains variable char - 58.
     174/      72 :                     ;		
     175/      72 :                     __IsVariable:
     176/      72 : 14 21               		sui 	91-58 											; if >= 91 this will be +ve
     177/      74 : 50 60 00            		jp 		ExitEvaluate1 								
     178/      77 : 04 1A               		adi 	26 												; if 0-25 then legit.
     179/      79 : 70 60 00            		jm 		ExitEvaluate1
     180/      7C : E6                  		mov 	e,l 											; save L in E
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 4 - 11/12/2016 12:23:03


     181/      7D : F0                  		mov 	l,a 											; L is variable index
     182/      7E : C5                  		mov 	a,h 											; save H in A
     183/      7F : 2E 10               		mvi 	h,VariablePage/256 								; HL points to variable
     184/      81 : DF                  		mov 	d,m 											; read value into D
     185/      82 : E8                  		mov 	h,a 											; restore HL from AE
     186/      83 : F4                  		mov 	l,e
     187/      84 : 44 45 00            		jmp 	NextCharacter 									; and get the next character
     188/      87 :                     ;
     189/      87 :                     ;	We want to do B <op:D> C D = 0:* 1:+ 2:, 3:- 4:. 5:/ into A - don't change E 
     190/      87 :                     ;
     191/      87 :                     SubEvaluator:
     192/      87 : 11                  		dcr 	c 												; check for multiply (0:*)
     193/      88 : 70 AB 00            		jm 		__SEMultiply 
     194/      8B : C1                  		mov 	a,b 											; work out add (1:+)
     195/      8C : 83                  		add 	d
     196/      8D : 11                  		dcr 	c
     197/      8E : 33                  		rm 
     198/      8F : C1                  		mov 	a,b 											; work out logical xor (2:,)
     199/      90 : AB                  		xra 	d
     200/      91 : 11                  		dcr 	c
     201/      92 : 33                  		rm 
     202/      93 : C1                  		mov 	a,b 											; work out subtract (3:-)
     203/      94 : 93                  		sub 	d
     204/      95 : 11                  		dcr 	c
     205/      96 : 33                  		rm
     206/      97 : C1                  		mov 	a,b 											; work out and (4:.)
     207/      98 : A3                  		ana 	d
     208/      99 : 11                  		dcr 	c
     209/      9A : 33                  		rm
     210/      9B :                     																; so it must be divide (5:/)
     211/      9B : 46 A0 00            		call 	__SEDivide 										; the result is in C so saves a jump.
     212/      9E : C2                  		mov 	a,c
     213/      9F : 07                  		ret
     214/      A0 :                     ;
     215/      A0 :                     ;	subtractive division.
     216/      A0 :                     ;
     217/      A0 :                     __SEDivide:	
     218/      A0 : C3                  		mov 	a,d 											; check divide by zero.
     219/      A1 : B0                  		ora 	a 
     220/      A2 : 2B                  		rz  													; will return $FF
     221/      A3 : C1                  		mov 	a,b 											; subtract D from this N times. C = 0
     222/      A4 :                     __SEDivide1:
     223/      A4 : 93                  		sub 	d
     224/      A5 : 23                  		rc
     225/      A6 : 10                  		inr 	c
     226/      A7 : 2B                  		rz
     227/      A8 : 44 A4 00            		jmp 	__SEDivide1
     228/      AB :                     ;
     229/      AB :                     ;	additive multiply
     230/      AB :                     ;
     231/      AB :                     __SEMultiply:	
     232/      AB : A8                  		xra 	a 												; total. (*0 becomes *256)
     233/      AC :                     __SEMultiply1:		
     234/      AC : 81                  		add 	b 												; add B to 0 D times.
     235/      AD : 19                  		dcr 	d
     236/      AE : 48 AC 00            		jnz 	__SEMultiply1
     237/      B1 : 07                  		ret
     238/      B2 :                     
     239/      B2 :                     ; ***********************************************************************************************
     240/      B2 :                     ; ***********************************************************************************************
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 5 - 11/12/2016 12:23:03


     241/      B2 :                     ;
     242/      B2 :                     ;									Print D as an integer
     243/      B2 :                     ;
     244/      B2 :                     ;	Breaks A,B,C,D
     245/      B2 :                     ; ***********************************************************************************************
     246/      B2 :                     ; ***********************************************************************************************
     247/      B2 :                     
     248/      B2 :                     PrintInteger:
     249/      B2 : 16 64               		mvi 	c,100 											; initial divisor
     250/      B4 :                     __PILoop:
     251/      B4 : 0E 2F               		mvi 	b,'0'-1 										; character to print/count division
     252/      B6 : C3                  		mov 	a,d 											; get integer
     253/      B7 :                     __PIDivide:
     254/      B7 : 08                  		inr 	b 												; one more 
     255/      B8 : D8                  		mov 	d,a 											; put pre-subtract back.
     256/      B9 : 92                  		sub 	c												; subtract divisor
     257/      BA : 40 B7 00            		jnc  	__PIDivide 										; keep going till a borrow.
     258/      BD : 15                  		rst 	PrintCharacter 									; print the result.
     259/      BE : C2                  		mov 	a,c  											; convert 100-10
     260/      BF : 14 5A               		sui 	90
     261/      C1 : D0                  		mov 	c,a
     262/      C2 : 40 B4 00            		jnc 	__PILoop 										; keep going if 10.
     263/      C5 : C3                  		mov 	a,d 											; get what is left
     264/      C6 : 34 30               		ori 	'0'												; make ASCII and print
     265/      C8 : C8                  		mov 	b,a 											; it out.
     266/      C9 : 15                  		rst 	PrintCharacter
     267/      CA : 07                  		ret
     268/      CB :                     
     269/      CB :                     ; ***********************************************************************************************
     270/      CB :                     ; ***********************************************************************************************
     271/      CB :                     ;
     272/      CB :                     ;										Execute Command at (HL)
     273/      CB :                     ;
     274/      CB :                     ; ***********************************************************************************************
     275/      CB :                     ; ***********************************************************************************************
     276/      CB :                     
     277/      CB :                     CommandExecute:
     278/      CB : 0D                  		rst 	GetNextCharacter 								; get character.
     279/      CC : C8                  		mov 	b,a 											; save in B
     280/      CD : 12                  		ral 													; shift left bit 6 into bit 7. basic # test
     281/      CE : B0                  		ora 	a 												; check if zero, signed.
     282/      CF : 2B                  		rz
     283/      D0 : 50 DE 00            		jp 		ProgramLine 									; if +ve it is a
     284/      D3 :                     
     285/      D3 :                     __SkipOverKeyword:
     286/      D3 : 0D                  		rst 	GetNextCharacter 								; get character
     287/      D4 : 04 9F               		adi 	256-97 											; CS if >= 97 e.g. lower case keyword
     288/      D6 : 60 D3 00            		jc 		__SkipOverKeyword 
     289/      D9 : 31                  		dcr 	l  												; unpick the last get.
     290/      DA : C1                  		mov 	a,b 											; get the first character back.
     291/      DB :                     
     292/      DB :                     		; 	check.
     293/      DB :                     
     294/      DB : 44 DB 00            wait1:	jmp 	wait1 			; execute command, 1st letter x 2 in A
     295/      DE :                     
     296/      DE :                     ; ***********************************************************************************************
     297/      DE :                     ;
     298/      DE :                     ;									Put a program line into memory.
     299/      DE :                     ;
     300/      DE :                     ; ***********************************************************************************************
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 6 - 11/12/2016 12:23:03


     301/      DE :                     ProgramLine:
     302/      DE : 31                  		dcr 	l 												; backspace to first character
     303/      DF : 3D                  		rst 	Evaluate 										; get line number into B, address into DE
     304/      E0 : D6                  		mov 	c,l 											; C is the low byte of the input line.
     305/      E1 : C1                  		mov 	a,b 											; exit if the line number is zero
     306/      E2 :                     __PLCopy:
     307/      E2 : B0                  		ora 	a
     308/      E3 : 2B                  		rz		
     309/      E4 : F2                  		mov 	l,c 											; read next byte from input line.
     310/      E5 : 2E 11               		mvi 	h,InputPage/256		
     311/      E7 : C7                  		mov 	a,m
     312/      E8 : EB                  		mov 	h,d 											; write it out to address DE
     313/      E9 : F4                  		mov 	l,e
     314/      EA : F8                  		mov 	m,a
     315/      EB : 10                  		inr 	c 												; increment two pointers
     316/      EC : 20                  		inr 	e 
     317/      ED : 44 E2 00            		jmp 	__PLCopy 										; jump back and return if zero.
     318/      F0 :                     
 AS V1.42 Beta [Bld 114] - source file basic.asm - page 7 - 11/12/2016 12:23:03


  symbol table (* = unused):
  ------------------------

 ADDDIGIT :                      3D C |
*ARCHITECTURE :                                        x86_64-unknown-linux - |
*BIGENDIAN :                      0 - | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  COMMANDEXECUTE :                CB C |
*CONSTPI :        3.141592653589793 - | *DATE :                  11/12/2016 - |
 EVALUATE :                      38 C |  EXITEVALUATE1 :                 60 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
 GETNEXTCHARACTER :               8 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
 INPUTLINE :                     18 C |  INPUTPAGE :                   1100 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*LISTON :                         1 - | *MACEXP :                         1 - |
*MOMCPU :                     8008E - | *MOMCPUNAME :               8008NEW - |
*NESTMAX :                      100 - |  NEXTCHARACTER :                 45 C |
 NEXTCOMMAND :                    0 C | *PACKING :                        0 - |
*PADDING :                        1 - |  PRINTCHARACTER :                10 C |
*PRINTINTEGER :                  B2 C |  PROGRAMLINE :                   DE C |
*PROGRAMMEMORY :               2000 - | *RELAXED :                        0 - |
 SUBEVALUATOR :                  87 C | *TIME :                    12:23:03 - |
*TRUE :                           1 - |  VARIABLEPAGE :                1000 - |
*VERSION :                     142F - |  WAIT1 :                         DB C |
 __CLNEXTCHARACTERINPUT :        20 C |  __CLPREVIOUSCHARACTER :         1C C |
 __CLSTARTLINE :                 1A C |  __ISVARIABLE :                  72 C |
 __PIDIVIDE :                    B7 C |  __PILOOP :                      B4 C |
 __PLCOPY :                      E2 C |  __SEDIVIDE :                    A0 C |
 __SEDIVIDE1 :                   A4 C |  __SEMULTIPLY :                  AB C |
 __SEMULTIPLY1 :                 AC C |  __SKIPOVERKEYWORD :             D3 C |

     56 symbols
     30 unused symbols

 AS V1.42 Beta [Bld 114] - source file basic.asm - page 8 - 11/12/2016 12:23:03


  codepages:
  ----------

STANDARD (0 changed characters)


0.00 seconds assembly time

    318 lines source file
      2 passes
      0 errors
      0 warnings
